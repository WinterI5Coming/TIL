# 구간 누적을 빠르게 처리하는 차분(Difference Array) 정리  
## (이동 경로 중복 구간 문제를 중심으로)

---

## 0. 문제 감각: 우리가 세는 건 “점”이 아니라 “구간”

이동 경로, 선분 겹침 문제에서 우리가 실제로 세는 대상은 **좌표 하나(점)** 가 아니라  
**좌표와 좌표 사이의 구간**이다.

예를 들어 배열 `arr`가 있을 때,

- `arr[i]`의 의미는 보통  
  👉 **구간 `i ~ i+1`을 지난 횟수**

### 예시
`3 → 6`으로 이동했다면, 우리가 세야 할 것은:

- `3~4`
- `4~5`
- `5~6`

총 **3개의 구간**이다.  
좌표 `6` 그 자체를 세는 게 아니다.

또 문제에서  
> “끝점에서 닿는 경우는 겹치지 않는다”  
라는 조건이 있으면, 구간을 반드시

- **[start, end)** (끝 미포함)

형태로 다뤄야 논리가 깨지지 않는다.

---

## 1. 직접 칠하기의 한계 → 차분이 필요한 이유

가장 직관적인 방법은 **직접 칠하기**다.

```python
for i in range(a, b):
    arr[i] += 1
```
이 방식은 이해하기 쉽지만,
- 이동 거리(또는 구간 길이)의 합이 커질수록

- 반복 횟수가 폭발적으로 증가

즉, 시간 복잡도가 너무 커진다.

---

## 2. 차분(Difference Array)의 핵심 아이디어
차분의 핵심 생각은 단순하다.

“구간 전체를 매번 업데이트하지 말고,
상태가 바뀌는 지점만 기록하자.”

구간 `[a, b)`에 `+1`을 하는 일을 다음 두 줄로 압축한다.

```python
diff[a] += 1   # a부터 +1 상태 시작
diff[b] -= 1   # b부터 +1 상태 종료
```
이렇게 하면,

- 실제로는 [a, b) 전체에 +1이 적용된 것과 같은 효과를 낸다.

이후 왼쪽부터 누적합을 돌리면 실제 값이 복원된다.

---

## 3. `cur`의 정확한 의미
차분 배열 `diff`에는 실제 값이 아니라
“얼마나 변했는지”에 대한 변화량만 들어 있다.

그래서 누적합이 필요하다.

```python
cur += diff[i]
```
여기서:

- `cur` = 현재 구간 `i ~ i+1`을 지난 실제 횟수

즉,

- 직접 칠하기에서의 `arr[i]` 값을

- 매번 저장하지 않고, `cur`로 실시간 복원하는 방식이다.

---

## 4. 스위프(sweep)는 무엇인가 (개념만)
스위프는 차분과 원리가 동일하다.

- 차분: 이벤트(+1 / -1)를 배열 인덱스에 기록

- 스위프: 이벤트(+1 / -1)를 정렬된 리스트에 기록

좌표가 실수이거나 범위가 너무 커서
배열을 만들기 어려울 때 스위프를 사용한다.

오늘의 진도는 차분까지이므로
스위프는 “차분의 배열 없는 버전” 정도로만 이해하면 충분하다.

---

## 5. 오늘 코드 기반: 차분 풀이 흐름 해부
아래는 이동 경로 중복 구간 문제를
차분 방식으로 푼 코드의 논리 흐름이다.
---
## 5-1. 이동을 무조건 구간 [a, b)로 통일한다
차분의 출발점은 모든 이동을 구간으로 바꾸는 것이다.

오른쪽 이동 (`R`)
```python
a = pos
b = pos + step
pos = pos + step
```
- 지나간 구간:
`pos~pos+1`, `pos+1~pos+2`, … , `pos+step-1~pos+step`

- 즉, [pos, pos+step)

왼쪽 이동 (`L`)
```python
a = pos - step
b = pos
pos = pos - step
```
- 지나간 구간:
`pos-1~pos`, `pos-2~pos-1`, … , `pos-step~pos-step+1`

즉, [pos-step, pos)

- 방향과 상관없이 모든 이동은 [a, b)로 표현 가능하다.
---
### 5-2. events 딕셔너리에 차분 이벤트 기록
```python
events[a] = events.get(a, 0) + 1
events[b] = events.get(b, 0) - 1
```
이는 곧
```python
diff[a] += 1
diff[b] -= 1
```
을 좌표 그대로 저장해둔 것이다.

딕셔너리를 쓰는 이유:

- 같은 좌표가 여러 번 등장할 수 있음 → 변화량 누적 필요

- 아직 좌표 범위를 모르기 때문에 배열을 바로 만들기 어려움
---
### 5-3. `min_pos`, `max_pos`가 필요한 이유
차분 배열을 만들려면 배열 크기가 필요하다.

하지만 이동하면서 좌표는:

- 음수 / 양수로 왔다 갔다 할 수 있음

그래서 실제로 등장한 좌표의 범위만 추적한다.
```python
max_pos = max(max_pos, a, b)
min_pos = min(min_pos, a, b)
```
정리하면:

- `min_pos`: 등장한 좌표 중 가장 작은 값

- `max_pos`: 등장한 좌표 중 가장 큰 값

- 배열은 결국 `[min_pos, max_pos]` 범위를 커버하면 충분
---
### 5-4. OFFSET의 역할 (음수 인덱스 방지)
파이썬 리스트는 음수 인덱스를 허용하지만,
의미가 완전히 달라지므로 사용하면 안 된다.

그래서 좌표계를 오른쪽으로 평행이동한다.
```python
OFFSET = -min_pos
```
이후 좌표 `s`는 항상
```python
배열 인덱스 = s + OFFSET
```
로 변환해서 사용한다.
```python
diff[s + OFFSET] += v
```
---
### 5-5. size에 왜 +2를 하는가 (여유의 의미)
```python
size = max_pos - min_pos + 2
```
차분에서는 구간 `[a, b)`에 대해

`b` 위치에도 `-1`을 반드시 기록해야 한다.

예: `[2, 5)`
```python
diff[2] += 1
diff[5] -= 1
```
우리는 5~6 구간을 세지 않지만,
“5에서 상태가 꺼진다”는 정보는 필요하다.

그래서:

- 실제 구간 수보다

- 끝점을 기록할 공간 + 안전 여유 1칸

을 더해 `+2`를 한다.

---

### 5-6. 누적합으로 실제 횟수 복원 + 답 계산
```python
cur = 0
cnt = 0
for i in range(len(diff) - 1):
    cur += diff[i]
    if cur >= 2:
        cnt += 1
print(cnt)
```
- `cur` = 구간 `i ~ i+1`을 지난 횟수

- `cur >= 2` → 2번 이상 겹친 구간

이 문제의 정답은 => `이런 구간의 개수`