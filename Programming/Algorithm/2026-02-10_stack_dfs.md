# 스택으로 DFS(완전탐색)할 때 정리

오늘은 두 문제를 **스택으로 DFS**로 풀었다.\
코드보다도 중요했던 건 "**스택에 어떤 상태를 넣을 것인가**"였다.

---

## 1. 스택 DFS의 본질
스택 DFS는 결국 다음과 같은 질문이다.
> "다음으로 탐색해야 할 **상태(state)**"는 무엇인가?

재귀 DFS에서 함수 인자로 넘기던 것들이\
=> 그대로 **스택에 들어갈 데이터**가 된다.

---

## 2. 상태(state) 설계 어떻게 해야 하지?

스택에 넣는 한 덩어리 = **현재 상황을 완전히 복원할 수 있는 최소 정보**여야 한다.

### (1) 위치/인덱스
- 다음 후보를 생성하기 위해서는 필수다.
- 좌표, 인덱스, 현재 값 등
- 예: `(x, y)`, `(left, right)`

### (2) 앞으로의 선택을 바꾸는 조건(제한/권한)
- “이미 한 번 사용했는가?”, “남은 기회가 몇 번인가?”, "한 번만 가능?" 등
- 예: `used_cut`, `used_flag`
- 이걸 빠뜨리면 같은 좌표라도 서로 다른 경우를 구분하지 못할 수 있다.

👉 **조건이 한 번이라도 달라지면 다른 상태다**

---

### (3) 누적값
- 경로 길이, 비용, 점수, 선택 개수 등

> 정답이 “최대/최소” 문제라면  
> → 누적값은 상태에 반드시 포함되어야 한다.

---

### (4) 재방문/중복 방지 정보
- 방문 여부, 이미 선택한 대상들
- `visited`/`path`/`selected_set`

방법은 두 가지:
- 상태에 `visited` / `path`를 포함
- 또는 push/pop 백트래킹 (더 어려움)

---

## 3. 등산로 문제에서의 STATE 설계 
등산로 문제에서 스택에 넣은 상태는 다음과 같았다.
```text
(x, y, cur_h, is_cut, path, visited)
```
각 요소의 의미는 다음과 같다.
- `(x,y)` => 현재 위치
- `cur_h` => 현재 비교 기준 높이 **(보드의 원본 높이가 아니라, 깎아서 내려온 경우 바뀔 수 있다)**
- `is_cut` => 깎기 사용 여부 (딱 한 번만 가능)
- `path` => 현재까지의 경로 (길이 계산용)
- `visited` => 현재 경로에서 방문한 좌표 집합 (재방문 방지)

---

## 4. 자주 발생하는 실수

### (1) **공유(얕은 복사) 버그**를 항상 의심
- `case.append(...)`, `visit.add(...)`를 여러 분기가 같이 쓰면 경로가 섞이게 된다.
- 해결을 다음과 같이 가능하다 :
  - 복사해서 push : `new_case = case + [...]`, `new_visit = visit + [...]`
  - push/pop 백트레킹 : 더 빠르지만 구현 난이도가 높다 (아직 안배움)

### (2) "보드/배열 직접 수정"은 웬만하면 피하기
- 분기 탐색에서 상태가 섞이게 된다.

### (3) 조건 경계(<=, <)하나로 케이스가 통째로 누락