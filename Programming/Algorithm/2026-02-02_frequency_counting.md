# 📌 숫자 카드 빈도 문제 – 알고리즘 TIL

## 1️⃣ 핵심 아이디어
이 문제는 **빈도 기반 문제(Frequency Counting)** 로 볼 수 있다.  
각 카드 번호가 몇 번 등장했는지를 세는 것이 핵심이며,  
단순히 가장 많이 등장한 값을 찾는 문제가 아니라  
**등장 횟수가 같은 경우의 우선순위 처리**까지 함께 고려해야 한다.

즉,
- 카드 번호 → 등장 횟수 형태로 데이터를 관리하고
- 빈도 정보를 기준으로 최댓값을 선택하는 문제이다.

이 문제를 보면  
**카운팅(Counting) + 동률 처리(tie-breaking)** 아이디어를 떠올려야 한다.

---

## 2️⃣ 해결 전략
1. dictionary를 사용해  
   - 카드 번호를 key  
   - 등장 횟수를 value  
   로 저장하며 관리한다.
2. 카드 문자열을 한 글자씩 순회하면서  
   - 처음 등장한 카드면 1로 초기화하고  
   - 이미 존재하는 카드면 등장 횟수를 증가시킨다.
3. 완성된 dictionary를 순회하면서  
   - 가장 많이 등장한 카드를 찾는다.
   - 등장 횟수가 같은 경우에는 **숫자가 더 큰 카드**를 선택한다.

카운팅 단계와 선택 단계를 분리해서 접근했다.

---

## 3️⃣ 구현 포인트
- `dict.get(key)` 메서드를 사용해 키 존재 여부를 확인했다.
- `get()`의 반환값을 기준으로 최초 등장과 재등장을 구분했다.
- 최댓값 갱신 시  
  - 등장 횟수 우선 비교  
  - 동률일 경우 카드 번호 비교  
  순으로 조건을 처리했다.
- 내장 함수 이름(`max`, `min`)과 겹치는 변수명 사용을 피해야 한다.

---

## 4️⃣ 개선 및 확장 아이디어

### 🔹 개선 1: `get()` 대신 `in` 사용
```python
if c in card_cnt:
    card_cnt[c] += 1
else:
    card_cnt[c] = 1
```
- 조건 분기가 더 직관적이다.
- 코드의 의도가 더 명확해진다.

### 🔹 개선 2: `defaultdict`활용
```python
from collections import defaultdict

card_cnt = defaultdict(int)
for c in card:
    card_cnt[c] += 1
```
- 초기값 처리 로직 제거
- 코드 길이 감소
- 카운팅 목적이 분명해진다.

### 🔹 확장 아이디어

- 카드 종류가 0~9로 고정된 경우
→ dictionary 대신 리스트 기반 카운팅으로 확장 가능

- 가장 많이 등장한 카드 1개가 아니라
→ 상위 k개 카드를 구하는 문제로 확장 가능

- 입력이 한 번에 주어지지 않고 스트림 형태로 들어와도
→ 동일한 카운팅 아이디어를 그대로 적용할 수 있다.