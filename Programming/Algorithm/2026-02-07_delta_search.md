# Delta 탐색(격자, 인접 탐색) 정리
격자(grid) 문제에서 "현재 칸 기준으로 이웃 칸을 빠르게 순회"하는 기본 도구이다.\
핵심은 **방향 로직을 코드에서 빼고, `(dr, dc)`라는 데이터로 고정**해서 실수 줄이고 재사용성 높이는 것.

---

## 1) 델타 탐색의 본질

- 현재 좌표 `(r, c)`에서 이웃 좌표 `(nr, nc)`는 항상 다음 형태로 만든다.
  - `nr = r + dr[d]`
  - `nc = c + dc[d]`
- 방향의 개수만큼 `d`를 돌면서 이웃을 검사/확장한다.
- 델타 탐색 자체는 “알고리즘”이라기보다 **이동/인접 순회의 패턴**이고,
  실제 문제는 보통 **BFS/DFS/시뮬레이션/DP** 같은 것과 결합된다.

---

## 2) 중요한 포인트

### (1) 방향 정의가 절반 이상이다
방향 배열의 **구성/순서/대각선 포함 여부**가 답을 좌우한다
- 4방향(상/하/좌/우)
    ```python
    dr = [-1, 1, 0, 0]
    dc = [0, 0, -1, 1]
    ```
- 8방향(대각선 포함)
  ```python
  dr = [-1, -1, -1, 0, 0, 1, 1, 1]
  dc = [-1,  0,  1, -1, 1, -1, 0, 1] 
  ```
- 방향 순서도 문제 요구와 연결된다.
  - 예: "왼쪽 먼저", "상-> 우 -> 하-> 좌 (시계)", "우선순위 이동 규칙" 등

### (2) 경계 체크는 "즉시"한다.
이웃 좌표를 만든 직후 바로 범위를 확인한다.
```python
nr = r + dr[d]
nc = c + dc[d]

if 0 <= nr < N and 0 <= nc < M:
    ...
```

- 실수
  - `N, M` 혼동(행/열)
  - `<=`를 안써서 인덱스 초과
  - 경계 체크 전에 grid 접근해서 런타임 에러

### (3) "모든 칸 순회" vs "특정 칸에서 확장"을 구분해야 한다.
델타 탐색은 크게 두 방식으로 나눌 수 있다.\

#### A. 모든 칸 순회 기반 델타 탐색
- 주변 값 합 / 최댓값 / 최솟값
- 특정 패턴 탐색
- 조건 만족 여부 검사
```python
for r in range(N):
    for c in range(M):
        for d in range(4):
            nr, nc = r + dr[d], c + dc[d]
            if 0 <= nr < N and 0 <= nc < M:
                ...
```

#### B. 특정 칸 기준 델타 탐색 (그래프 탐색형)
- 목적 : 최단거리, 영역 탐색, 전파/확산
```python
from collections import deque

q = deque([(sr, sc)])
visited[sr][sc] = True

while q:
    r, c = q.popleft()
    for d in range(4):
        nr, nc = r + dr[d], c + dc[d]
        if 0 <= nr < N and 0 <= nc < M and not visited[nr][nc]:
            visited[nr][nc] = True
            q.append((nr, nc))
```
---

## 3) 대표 문제 유형 정리(델타 탐색 쓰이는 곳)

### (1) 영역(덩어리) 개수 세기

### (2) 최단거리 / 최소 이동 횟수

### (3) 전파 / 확산 문제

### (4) 시뮬레이션(격자 변화)    

### (5) 경로 찾기 (조건 있음)

### (6) 누적 최댓값 / 최솟값 (방향 제한)



---