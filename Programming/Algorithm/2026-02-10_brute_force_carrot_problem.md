# 🥕 완전탐색으로 분할 최적화 문제 풀기 (당근 포장 문제)

## 📌 문제 요약
N개의 당근이 주어질 때, 이를 **대 / 중 / 소 3개의 상자**로 나눈다.  
다음 조건을 모두 만족해야 한다.

1. 같은 크기의 당근은 반드시 같은 상자에 들어가야 한다.
2. 빈 상자는 존재할 수 없다.
3. 한 상자에는 최대 `N//2`개까지만 담을 수 있다.
4. 위 조건을 만족하는 경우 중 **각 상자의 당근 개수 차이의 최소값**을 구한다.  
   (불가능하면 `-1` 출력)

---

## 📌 접근 아이디어

이 문제는 단순 구현 문제가 아니라  
**조건이 많은 “분할 최적화 문제”**로 볼 수 있다.

핵심 아이디어는 다음과 같다.

1. **사전 불가능 판정**
2. **정렬**
3. **완전탐색으로 모든 분할 경우 생성**
4. **조건에 맞는 경우만으로 최적값 갱신**
5. **정답이 하나도 없는 경우 처리**

---

## 1. 사전 불가능 판정 (Early Exit)

어떤 크기의 당근이 `N//2`개를 초과하면  
어느 상자에도 담을 수 없으므로 **바로 불가능**하다.

```python
carrot_cnt = defaultdict(int)
for size in carrot_list:
    carrot_cnt[size] += 1

if max(carrot_cnt.values()) > carrot_limit:
    print(f"#{test_case} -1")
    continue
```
해당 단계는 완전탐색을 돌리기 전에 불필요한 연산을 차단하는 역할을 한다.

---

## 2. 정렬이 필수였던 이유 (가장 어려웠던 부분)

사용한 분할 방식은 연속 슬라이싱이었다.
```python
box1 = carrot_list[:a]
box2 = carrot_list[a:a + b]
box3 = carrot_list[a + b:]
```
이 방식이 성립하기 위해서는 같은 크기의 당근이 연속적으로 붙어 있어야 한다.\
따라서 입력이 정렬되어 있지 않으면,\
아무리 조건 검사를 해도 올바른 분할 자체를 만들 수 없다.

그래서 완전탐색 전에 정렬을 진행했다.
```python
carrot_list.sort()
```

---

## 3. 모든 경우의 수를 만드는 2중 for문

- 첫 번째 상자에서 `n`개 중에서 `a`개를 골라서 넣는다
- 두 번째 상자에서 `n-a`개 중에서 `b`개를 골라서 넣는다
- 나머지는 자동 3번 상자
```python
for a in range(1, carrot_limit + 1):
    for b in range(1, min(carrot_limit, n - a - 1) + 1):
        box1 = carrot_list[:a]
        box2 = carrot_list[a:a + b]
        box3 = carrot_list[a + b:]
```
   - 단 모든 상자에는 반드시 1개 이상이 들어가야 하기 때문에,
     - 2번째 상자에서 고를 때 최대값을 다음과 같이 설정했다.

---

## 4. 최종 결과 처리에서의 실수
처음에는 아래처럼 출력했었고 통과하지 못했었다.
```python
print(f"#{test_case} {result}")
```
이유는 다음과 같았다
   - 모든 경우의 수가 `continue`로 탈락하면
   - `result`는 초기값(`9999999`) 그대로 남는다
   - 이 경우는 **정답이 없는 경우(-1)**인데 이를 처리하지 못했다.
그래서 최종 출력은 반드시 다음과 같이 해야 했다.
```python
print(f"#{test_case} {-1 if result == 9999999 else result}")
```
=> 즉, "continue로 거르는 것"과 "정답이 아예 없는 경우"는 다르다는 것이다.