# 날짜·시간 알고리즘 정리

날짜/시간 문제는 **시뮬레이션(1초/1분/1일씩 while)** 로 풀면 쉽게 시간초과·버그가 난다.  
정석은 **“표현을 숫자로 바꾸고(누적값), 빼기/나머지/구간 연산으로 끝내는 것”** 이다.

---

## 1. 최우선 원칙: 단위를 통일해서 숫자로 만들기

### 1) 시간(시/분/초)은 총 초·총 분으로
- `(h, m, s)` → `h * 3600 + m * 60 + s`
- `(day, h, m)` → `day * 1440 + h * 60 + m`

**차이**는 한 줄:
- `diff = now - target`

**포함 범위**(시작~끝 포함)는 문제 조건에 따라:
- `diff + 1` 또는 `diff` 중 하나가 정답이 된다.

### 2) 날짜(월/일)는 누적일(ordinal), 연/월/일은 절대일수(absolute day)로
- 같은 해 내부: `(m, d)` → `ordinal(m, d)`
- 여러 해 포함: `(y, m, d)` → `absolute_day(y, m, d)`

---

## 2. 날짜 비교는 튜플 비교로 끝내기

날짜/시간 비교는 부분 비교(`a<11 or b<11`)가 아니라 **전체 순서 비교**로 해야 한다.

- `(y1, m1, d1) < (y2, m2, d2)`
- `(m1, d1) <= (m2, d2)`
- `(day, hour, minute) >= (11, 11, 11)`

이 방식이 제일 안전하고 코드가 짧다.

---

## 3. 같은 해에서 (월, 일) → 누적일(ordinal) 템플릿

### prefix 만들기
- `prefix[i]`를 “1월부터 i월 전까지 누적 일수”로 두면 가장 편하다.
- 그래서 `prefix[0] = 0`이 핵심이다.

```python
month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
prefix = [0]
for x in month_days:
    prefix.append(prefix[-1] + x)

def ordinal(m, d):
    return prefix[m - 1] + d
```

### 날짜 차이(방향 포함)
```python
day_diff = ordinal(m2, d2) - ordinal(m1, d1)
```

## 4. 요일 문제의 정석: 차이 + 모듈러
요일 리스트를 이렇게 두면:
```python
day_list = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
```
- 기준 날짜가 Mon일 때, 다른 날짜의 요일은:
```python
print(day_list[day_diff % 7])
```
파이썬은 음수도 % 7이 자연스럽게 처리된다.

예: `-1 % 7 == 6` → 하루 전은 `Sun`

---
## 5. 윤년/월 길이: 템플릿으로 박아두기
윤년(그레고리력):

- 400의 배수: 윤년

- 100의 배수: 평년

- 4의 배수: 윤년

- 그 외: 평년
```python
def is_leap(y):
    return (y % 400 == 0) or (y % 4 == 0 and y % 100 != 0)

def month_len(y, m):
    md = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if m == 2 and is_leap(y):
        return 29
    return md[m - 1]
```

---
## 6. 자주 나오는 다른 유형들 + 정석 접근
### 유형 A) “두 시각/날짜의 차이”
- 누적값으로 바꾸고 빼기

- 포함/미포함만 체크

### 유형 B) “N일/ N분 뒤의 날짜(시간)”
1. 누적값으로 변환

2. `t2 = t + N`

3. 필요하면 역변환

### 유형 C) “다음 이벤트(주기)”
- 예: 15분마다 버스, 다음 도착 시각

- period가 있으면 나머지로 처리:

  - next = now + ((period - now % period) % period)

  - 시작 시각이 따로 있으면 now - start 기준으로 모듈러

### 유형 D) “구간 겹침/스케줄 교집합”
- 시간을 전부 분/초로 통일

- 구간은 보통 [start, end) 형태로 통일해서 처리

- 정렬 후 스윕/병합

### 유형 E) “동시 발생 최대(로그 분석)”
- 시작: +1, 종료: -1 이벤트로 만들어 정렬

- 누적합의 최댓값이 답

### 유형 F) “특정 조건 날짜 카운트”
- 예: 금요일 13일 몇 번?

- 월/일을 ordinal로 바꾸고 요일을 빠르게 계산해서 체크

- 하루씩 돌리기보다 월 단위로 계산하는 편이 안전

## 7. 실전 체크리스트(자주 틀리는 포인트)
1. 포함/미포함: `[start, end]` 인지 `[start, end)` 인지

2. 경계: 월말, 23:59:59, 2월 28/29

3. 비교는 튜플: 부분 비교 금지

4. 단위 통일: 초/분/일을 섞지 말고 하나로

5. while 시뮬레이션은 최후의 수단: 범위가 크면 거의 시간초과

